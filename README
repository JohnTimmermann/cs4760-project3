Name: John Timmermann
Date: 10/15/2025
Environment: opsys, linux, vim

How to compile the project:
Type `make` in the terminal. This will create two executables: `oss` and `worker`.

Example of how to run the project:
To run the simulation, use the `oss` executable. Here is an example with all options:
./oss -n 10 -s 5 -t 7 -i 0.5 -f logfile.txt

Command-Line Options:
-n [proc]: The total number of child processes to launch.
-s [simul]: The number of child processes that can run simultaneously.
-t [time]: The bound of time a child process will have, in seconds.
-i [interval]: The interval in milliseconds for launching new children.
-f [logfile]: The name of the file to log the output of the `oss` process.

Problems Encountered:
I initially had a race condition when cleaning up terminated processes because I was using a non-blocking waitpid() call alongside the new message queue system. I resolved this by moving to a blocking waitpid() only after a child signaled its intent to terminate via a message.

Generative AI Used: Gemini

Prompts:
- How do I set up a System V message queue in C++?
- Can you show me how to modify my main loop to send a message to one child at a time and wait for a response?
- What is a good way to handle logging to both the console and a file in C++?
- Please review my `oss.cpp` code for any logical errors.

Summary:
I used Gemini to understand the best way to implement the System V message queues which were new to me. It helped me with making the main scheduler loop in `oss` to handle the new "tight coordination" by sending a message and waiting for a reply before proceeding. I also used it to refactor my logging output function. It was very helpful for catching a logic errors where I had left in an old, redundant `waitpid` loop that conflicted with the new messaging system.
